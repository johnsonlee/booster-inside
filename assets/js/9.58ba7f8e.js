(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{357:function(t,e,r){"use strict";r.r(e);var _=r(33),v=Object(_.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"高性能文件系统-i-o"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#高性能文件系统-i-o"}},[t._v("#")]),t._v(" 高性能文件系统 I/O")]),t._v(" "),r("h2",{attrs:{id:"仅一次文件系统-i-o"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#仅一次文件系统-i-o"}},[t._v("#")]),t._v(" 仅一次文件系统 I/O")]),t._v(" "),r("p",[t._v("在 "),r("RouterLink",{attrs:{to:"/architecture/transformer-pipeline.html"}},[t._v("字节码处理流水线")]),t._v(" 这一章中，我们了解到 "),r("em",[t._v("Android Gradle Plugin")]),t._v(" 是以流水线的方式来处理字节码的，"),r("code",[t._v("BoosterTransform")]),t._v(" 作为 "),r("em",[t._v("Transform Pipeline")]),t._v(" 中的一个节点，负责从 "),r("code",[t._v("TransformStream")]),t._v(" 中接收输入（"),r("em",[t._v("JAR")]),t._v(" 或者目录），然后经过处理后，再输出到指定的路径，"),r("em",[t._v("Booster")]),t._v(" 对 "),r("em",[t._v("JAR")]),t._v(" 文件的处理方式是一边读一边进行处理，而不是将 "),r("em",[t._v("JAR")]),t._v(" 解压到磁盘再读，这样作的好处有：")],1),t._v(" "),r("ol",[r("li",[r("p",[t._v("减少 "),r("em",[t._v("I/O")]),t._v(" 开销；")]),t._v(" "),r("p",[t._v("如果是先将 "),r("em",[t._v("JAR")]),t._v(" 解压到磁盘再读取其中的 "),r("em",[t._v("class")]),t._v("，每处理完一个 "),r("em",[t._v("class")]),t._v(" 还需要再写一次文件，无形中会多出 "),r("em",[t._v("2N")]),t._v(" 次 "),r("em",[t._v("I/O")]),t._v(" 操作（"),r("em",[t._v("N")]),t._v(" 为 "),r("em",[t._v("JAR")]),t._v(" 中 "),r("em",[t._v("class")]),t._v(" 的数量），而且遍历目录也会存在性能损耗，通过 "),r("em",[t._v("benchmark")]),t._v(" 测试，我们发现，先解压再处理的方式在性能表现上远不及一边读一边处理。")])]),t._v(" "),r("li",[r("p",[t._v("避免因不同的 "),r("em",[t._v("JAR")]),t._v(" 中包含同名的 "),r("em",[t._v("class")]),t._v(" 导致解压到磁盘时被同名的 "),r("em",[t._v("class")]),t._v(" 所覆盖的问题；")]),t._v(" "),r("p",[t._v("在平常的开发过程中，可能有些模块会将本地 "),r("em",[t._v("JAR")]),t._v(" 打包进 "),r("em",[t._v("AAR")]),t._v(" 中，如果两个不同的模块都依赖了相同的本地 "),r("em",[t._v("JAR")]),t._v(" 的不同版本，采用先解压的方式可能会将这种情况掩盖，更有可能旧版本覆盖新版本等诸多无法预测的问题。")])])]),t._v(" "),r("h2",{attrs:{id:"并行-i-o"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#并行-i-o"}},[t._v("#")]),t._v(" 并行 I/O")]),t._v(" "),r("h3",{attrs:{id:"并行处理-class"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#并行处理-class"}},[t._v("#")]),t._v(" 并行处理 class")]),t._v(" "),r("p",[t._v("在 "),r("RouterLink",{attrs:{to:"/architecture/transformer-pipeline.html"}},[t._v("字节码处理流水线")]),t._v(" 这一章中，我们了解到 "),r("em",[t._v("Booster")]),t._v(" 采用了并行 "),r("em",[t._v("Transfomer Pipeline")]),t._v(" 的方案，不仅如此，在字节码处理完成之后，输出 "),r("em",[t._v("JAR")]),t._v(" 的过程中，同样采用了并行写的方式，通过对 "),r("code",[t._v("$ANDROID_HOME/platforms/android-28/android.jar")]),t._v(" 进行 "),r("em",[t._v("benchmark")]),t._v(" 测试，我们发现串行 "),r("em",[t._v("I/O")]),t._v(" 的平均耗时几乎是并行 "),r("em",[t._v("I/O")]),t._v(" 一倍，"),r("em",[t._v("benchmark")]),t._v(" 测试结果如下表所示：")],1),t._v(" "),r("table",[r("thead",[r("tr",[r("th",[t._v("Benchmark")]),t._v(" "),r("th",{staticStyle:{"text-align":"center"}},[t._v("Mode")]),t._v(" "),r("th",{staticStyle:{"text-align":"center"}},[t._v("Cnt")]),t._v(" "),r("th",{staticStyle:{"text-align":"center"}},[t._v("Score")]),t._v(" "),r("th",{staticStyle:{"text-align":"center"}},[t._v("Error")]),t._v(" "),r("th",{staticStyle:{"text-align":"center"}},[t._v("Units")])])]),t._v(" "),r("tbody",[r("tr",[r("td",[t._v("transformJarFileSequentially")]),t._v(" "),r("td",{staticStyle:{"text-align":"center"}},[t._v("avgt")]),t._v(" "),r("td",{staticStyle:{"text-align":"center"}},[t._v("10")]),t._v(" "),r("td",{staticStyle:{"text-align":"center"}},[t._v("1261.791")]),t._v(" "),r("td",{staticStyle:{"text-align":"center"}},[t._v("± 13.966")]),t._v(" "),r("td",{staticStyle:{"text-align":"center"}},[t._v("ms/op")])]),t._v(" "),r("tr",[r("td",[t._v("transformJarFileWithFixedThreadPool")]),t._v(" "),r("td",{staticStyle:{"text-align":"center"}},[t._v("avgt")]),t._v(" "),r("td",{staticStyle:{"text-align":"center"}},[t._v("10")]),t._v(" "),r("td",{staticStyle:{"text-align":"center"}},[t._v("708.439")]),t._v(" "),r("td",{staticStyle:{"text-align":"center"}},[t._v("± 37.973")]),t._v(" "),r("td",{staticStyle:{"text-align":"center"}},[t._v("ms/op")])])])]),t._v(" "),r("h3",{attrs:{id:"并行遍历文件"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#并行遍历文件"}},[t._v("#")]),t._v(" 并行遍历文件")]),t._v(" "),r("p",[t._v("通常我们遍历目录会使用 "),r("code",[t._v("File.listFiles(...)")]),t._v(" 或者 "),r("code",[t._v("FileTreeWalker")]),t._v("，对于为数不多的文件来说，并没有什么弊端，但是，对于拥有成千上万个 "),r("em",[t._v("class")]),t._v(" 的工程来说，这种串行遍历文件系统的方式在性能上就会表现出明显的不足，为了最大限度的提升构建速度，"),r("em",[t._v("Booster")]),t._v(" 提供了 "),r("a",{attrs:{href:"https://github.com/didi/booster/blob/master/booster-kotlinx/src/main/kotlin/com/didiglobal/booster/kotlinx/FileSearch.kt",target:"_blank",rel:"noopener noreferrer"}},[t._v("FileSearch"),r("OutboundLink")],1),t._v(" 实用类，通过 "),r("a",{attrs:{href:"https://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Fork/Join Framework"),r("OutboundLink")],1),t._v(" 来实现文件系统的并行遍历，像 "),r("em",[t._v("class")]),t._v(" 文件遍历，图片资源遍历等都使用了并行遍历的方式。")]),t._v(" "),r("p",[t._v("另外，"),r("a",{attrs:{href:"https://github.com/didi/booster/blob/master/booster-kotlinx",target:"_blank",rel:"noopener noreferrer"}},[t._v("booster-kotlinx"),r("OutboundLink")],1),t._v(" 模块还提供了一系列的扩展方法来提升插件开发的便利性，详情请参见："),r("a",{attrs:{href:"https://reference.johnsonlee.io/booster/com.didiglobal.booster.kotlinx/index.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Package com.didiglobla.booster.kotlinx"),r("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=v.exports}}]);